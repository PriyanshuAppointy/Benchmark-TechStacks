const fs = require('fs');
const path = require('path');

class HTMLReportGenerator {
    constructor() {
        this.reportsDir = 'reports';
        this.outputFile = 'reports/index.html';
    }

    async generateReport() {
        try {
            console.log('üîç Scanning for JSON reports...');
            const reports = await this.loadReports();
            
            if (reports.length === 0) {
                console.log('‚ùå No JSON reports found');
                return;
            }

            console.log(`üìä Found ${reports.length} report(s), generating HTML...`);
            const html = this.generateHTML(reports);
            
            await fs.promises.writeFile(this.outputFile, html);
            console.log(`‚úÖ HTML report generated: ${this.outputFile}`);
            
        } catch (error) {
            console.error('‚ùå Error generating HTML report:', error);
            process.exit(1);
        }
    }

    async loadReports() {
        const files = await fs.promises.readdir(this.reportsDir);
        const jsonFiles = files.filter(file => file.endsWith('.json'));
        
        const reports = [];
        for (const file of jsonFiles) {
            try {
                const filePath = path.join(this.reportsDir, file);
                const content = await fs.promises.readFile(filePath, 'utf8');
                const report = JSON.parse(content);
                reports.push({ filename: file, ...report });
            } catch (error) {
                console.warn(`‚ö†Ô∏è  Skipping invalid JSON file: ${file}`);
            }
        }
        
        return reports.sort((a, b) => new Date(b.metadata.reportGeneratedAt) - new Date(a.metadata.reportGeneratedAt));
    }

    generateHTML(reports) {
        const latestReport = reports[0];
        const allResults = this.aggregateResults(reports);
        
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchie-techs Performance Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        ${this.getStyles()}
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üöÄ Benchie-techs Performance Report</h1>
            <div class="header-meta">
                <span class="badge">Latest: ${new Date(latestReport.metadata.reportGeneratedAt).toLocaleString()}</span>
                <span class="badge">Reports: ${reports.length}</span>
            </div>
        </header>

        ${this.generateSystemInfo(latestReport.metadata)}
        ${this.generateSummaryCards(latestReport.results)}
        ${this.generatePerformanceCharts(allResults)}
        ${this.generateDetailedResults(latestReport.results)}
        ${this.generateHistoricalData(reports)}
        ${this.generateTechnicalDetails(latestReport)}
        
        <footer class="footer">
            <p>Generated by Benchie-techs ‚Ä¢ ${new Date().toLocaleString()}</p>
            <p>üîó <a href="https://github.com/appointy/Benchie-techs">View Source Code</a></p>
        </footer>
    </div>

    <script>
        ${this.getJavaScript(allResults)}
    </script>
</body>
</html>`;
    }

    generateSystemInfo(metadata) {
        const { systemInfo, toolVersions } = metadata;
        return `
        <section class="system-info">
            <h2>üñ•Ô∏è System Information</h2>
            <div class="info-grid">
                <div class="info-card">
                    <h3>Hardware</h3>
                    <ul>
                        <li><strong>OS:</strong> ${systemInfo.os} (${systemInfo.arch})</li>
                        <li><strong>CPU:</strong> ${systemInfo.cpu}</li>
                        <li><strong>Cores:</strong> ${systemInfo.cores}</li>
                        <li><strong>Memory:</strong> ${Math.round(systemInfo.totalMemoryMB).toLocaleString()} MB</li>
                    </ul>
                </div>
                <div class="info-card">
                    <h3>Tool Versions</h3>
                    <ul>
                        ${Object.entries(toolVersions.versions).map(([tool, version]) => 
                            `<li><strong>${tool}:</strong> ${version}</li>`
                        ).join('')}
                    </ul>
                </div>
            </div>
        </section>`;
    }

    generateSummaryCards(results) {
        const byTech = this.groupByTechnology(results);
        const topPerformers = this.getTopPerformers(results);
        
        return `
        <section class="summary">
            <h2>üìà Performance Summary</h2>
            <div class="summary-cards">
                <div class="summary-card winner">
                    <h3>üèÜ Top Performer</h3>
                    <div class="metric-large">${topPerformers.fastest.tech}</div>
                    <div class="metric-label">${topPerformers.fastest.test}</div>
                    <div class="metric-value">${topPerformers.fastest.ops.toLocaleString()} ops/sec</div>
                </div>
                <div class="summary-card">
                    <h3>‚ö° Total Tests</h3>
                    <div class="metric-large">${results.length}</div>
                    <div class="metric-label">Across ${Object.keys(byTech).length} technologies</div>
                </div>
                <div class="summary-card">
                    <h3>üß† Memory Champion</h3>
                    <div class="metric-large">${topPerformers.mostEfficient.tech}</div>
                    <div class="metric-label">${topPerformers.mostEfficient.test}</div>
                    <div class="metric-value">${topPerformers.mostEfficient.memory.toFixed(1)} MB</div>
                </div>
            </div>
        </section>`;
    }

    generatePerformanceCharts(allResults) {
        return `
        <section class="charts">
            <h2>üìä Performance Visualization</h2>
            <div class="chart-grid">
                <div class="chart-container">
                    <h3>Operations per Second by Technology</h3>
                    <canvas id="opsChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Memory Usage Comparison</h3>
                    <canvas id="memoryChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>CPU Usage by Test Type</h3>
                    <canvas id="cpuChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Execution Time Distribution</h3>
                    <canvas id="timeChart"></canvas>
                </div>
            </div>
        </section>`;
    }

    generateDetailedResults(results) {
        const byTech = this.groupByTechnology(results);
        
        return `
        <section class="detailed-results">
            <h2>üîç Detailed Results</h2>
            ${Object.entries(byTech).map(([tech, techResults]) => `
                <div class="tech-section">
                    <h3>${this.getTechIcon(tech)} ${tech.charAt(0).toUpperCase() + tech.slice(1)}</h3>
                    <div class="results-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Test</th>
                                    <th>Ops/Second</th>
                                    <th>Total Time</th>
                                    <th>Memory (MB)</th>
                                    <th>CPU (%)</th>
                                    <th>Performance</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${techResults.map(result => `
                                    <tr>
                                        <td><code>${result.test}</code></td>
                                        <td class="metric">${result.metrics.operationsPerSecond?.toLocaleString() || 'N/A'}</td>
                                        <td class="metric">${result.metrics.totalTimeMs?.toFixed(2) || 'N/A'}ms</td>
                                        <td class="metric">${result.metrics.maxMemoryMB?.toFixed(1) || 'N/A'}</td>
                                        <td class="metric">${result.metrics.avgCpuPercent?.toFixed(1) || 'N/A'}</td>
                                        <td>${this.getPerformanceRating(result.metrics.operationsPerSecond)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `).join('')}
        </section>`;
    }

    generateHistoricalData(reports) {
        if (reports.length <= 1) return '';
        
        return `
        <section class="historical">
            <h2>üìÖ Historical Performance</h2>
            <div class="historical-chart">
                <canvas id="historicalChart"></canvas>
            </div>
            <div class="report-list">
                <h3>Previous Reports</h3>
                <ul>
                    ${reports.slice(1, 6).map(report => `
                        <li>
                            <span class="date">${new Date(report.metadata.reportGeneratedAt).toLocaleDateString()}</span>
                            <span class="results-count">${report.results.length} results</span>
                        </li>
                    `).join('')}
                </ul>
            </div>
        </section>`;
    }

    generateTechnicalDetails(report) {
        return `
        <section class="technical-details">
            <h2>üîß Technical Details</h2>
            <details>
                <summary>Raw JSON Data</summary>
                <pre class="json-data">${JSON.stringify(report, null, 2)}</pre>
            </details>
        </section>`;
    }

    // Helper methods
    aggregateResults(reports) {
        return reports.flatMap(report => report.results);
    }

    groupByTechnology(results) {
        return results.reduce((acc, result) => {
            if (!acc[result.tech]) acc[result.tech] = [];
            acc[result.tech].push(result);
            return acc;
        }, {});
    }

    getTopPerformers(results) {
        const fastest = results.reduce((max, result) => 
            (result.metrics.operationsPerSecond || 0) > (max.ops || 0) 
                ? { tech: result.tech, test: result.test, ops: result.metrics.operationsPerSecond }
                : max
        , { ops: 0 });

        const mostEfficient = results.reduce((min, result) => 
            (result.metrics.maxMemoryMB || Infinity) < (min.memory || Infinity)
                ? { tech: result.tech, test: result.test, memory: result.metrics.maxMemoryMB }
                : min
        , { memory: Infinity });

        return { fastest, mostEfficient };
    }

    getTechIcon(tech) {
        const icons = {
            'go': 'üêπ',
            'node': 'üü¢', 
            'bun': 'ü•ñ',
            'python': 'üêç',
            'rust': 'ü¶Ä'
        };
        return icons[tech] || 'üíª';
    }

    getPerformanceRating(ops) {
        if (!ops) return '‚ùì N/A';
        if (ops > 10000) return 'üöÄ Excellent';
        if (ops > 5000) return '‚ö° Good';
        if (ops > 1000) return '‚úÖ Average';
        return 'üê¢ Slow';
    }

    getStyles() {
        return `
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            margin-top: -20px;
            margin-left: -20px;
            margin-right: -20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header-meta {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .badge {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .system-info, .summary, .charts, .detailed-results, .historical, .technical-details {
            margin-bottom: 40px;
        }
        
        .system-info h2, .summary h2, .charts h2, .detailed-results h2, .historical h2, .technical-details h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .info-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .info-card h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .info-card ul {
            list-style: none;
        }
        
        .info-card li {
            padding: 5px 0;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .summary-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .summary-card.winner {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            transform: scale(1.05);
        }
        
        .summary-card h3 {
            margin-bottom: 15px;
            color: #666;
        }
        
        .metric-large {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        
        .metric-value {
            color: #667eea;
            font-weight: bold;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .chart-container h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }
        
        .tech-section {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .tech-section h3 {
            background: #667eea;
            color: white;
            padding: 15px 20px;
            margin: 0;
            font-size: 1.3em;
        }
        
        .results-table {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background: #f1f3f4;
            font-weight: 600;
            color: #333;
        }
        
        .metric {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: bold;
            color: #667eea;
        }
        
        code {
            background: #e9ecef;
            padding: 3px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .json-data {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .footer {
            text-align: center;
            padding: 40px 0;
            color: #666;
            border-top: 1px solid #e9ecef;
            margin-top: 40px;
        }
        
        .footer a {
            color: #667eea;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        details {
            margin-top: 20px;
        }
        
        summary {
            cursor: pointer;
            font-weight: bold;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        summary:hover {
            background: #e9ecef;
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header { margin: -10px; }
            .chart-grid { grid-template-columns: 1fr; }
            .summary-cards { grid-template-columns: 1fr; }
            .info-grid { grid-template-columns: 1fr; }
        }
        `;
    }

    getJavaScript(allResults) {
        const byTech = this.groupByTechnology(allResults);
        const chartData = this.prepareChartData(byTech);
        
        return `
        // Chart.js configuration
        const chartOptions = {
            responsive: true,
            plugins: {
                legend: { position: 'top' },
                tooltip: { mode: 'index', intersect: false }
            },
            scales: {
                y: { beginAtZero: true }
            }
        };

        // Operations per Second Chart
        new Chart(document.getElementById('opsChart'), {
            type: 'bar',
            data: {
                labels: ${JSON.stringify(chartData.testNames)},
                datasets: ${JSON.stringify(chartData.opsDatasets)}
            },
            options: chartOptions
        });

        // Memory Usage Chart
        new Chart(document.getElementById('memoryChart'), {
            type: 'bar',
            data: {
                labels: ${JSON.stringify(chartData.testNames)},
                datasets: ${JSON.stringify(chartData.memoryDatasets)}
            },
            options: chartOptions
        });

        // CPU Usage Chart
        new Chart(document.getElementById('cpuChart'), {
            type: 'line',
            data: {
                labels: ${JSON.stringify(chartData.testNames)},
                datasets: ${JSON.stringify(chartData.cpuDatasets)}
            },
            options: chartOptions
        });

        // Time Distribution Chart
        new Chart(document.getElementById('timeChart'), {
            type: 'doughnut',
            data: {
                labels: ${JSON.stringify(chartData.timeLabels)},
                datasets: [{
                    data: ${JSON.stringify(chartData.timeData)},
                    backgroundColor: ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff']
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { position: 'bottom' }
                }
            }
        });
        `;
    }

    prepareChartData(byTech) {
        const colors = {
            'go': '#00ADD8',
            'node': '#339933', 
            'bun': '#FBF0DF',
            'python': '#3776AB',
            'rust': '#CE422B'
        };

        const testNames = [...new Set(Object.values(byTech).flat().map(r => r.test))];
        
        const opsDatasets = Object.entries(byTech).map(([tech, results]) => ({
            label: tech.charAt(0).toUpperCase() + tech.slice(1),
            data: testNames.map(test => {
                const result = results.find(r => r.test === test);
                return result?.metrics.operationsPerSecond || 0;
            }),
            backgroundColor: colors[tech] || '#667eea'
        }));

        const memoryDatasets = Object.entries(byTech).map(([tech, results]) => ({
            label: tech.charAt(0).toUpperCase() + tech.slice(1),
            data: testNames.map(test => {
                const result = results.find(r => r.test === test);
                return result?.metrics.maxMemoryMB || 0;
            }),
            backgroundColor: colors[tech] || '#667eea'
        }));

        const cpuDatasets = Object.entries(byTech).map(([tech, results]) => ({
            label: tech.charAt(0).toUpperCase() + tech.slice(1),
            data: testNames.map(test => {
                const result = results.find(r => r.test === test);
                return result?.metrics.avgCpuPercent || 0;
            }),
            borderColor: colors[tech] || '#667eea',
            fill: false
        }));

        const timeData = Object.values(byTech).map(results => 
            results.reduce((sum, r) => sum + (r.metrics.totalTimeMs || 0), 0)
        );
        const timeLabels = Object.keys(byTech).map(tech => 
            tech.charAt(0).toUpperCase() + tech.slice(1)
        );

        return {
            testNames,
            opsDatasets,
            memoryDatasets, 
            cpuDatasets,
            timeData,
            timeLabels
        };
    }
}

// Execute the generator
if (require.main === module) {
    const generator = new HTMLReportGenerator();
    generator.generateReport();
}

module.exports = HTMLReportGenerator; 