---
alwaysApply: true
description: Framework benchmark inclusion criteria - when to create framework-specific tests vs using runtime tests
---

# Framework Benchmark Inclusion Criteria

When creating framework-specific benchmark implementations (e.g., `hono-bun`, `hono-node`, `express-node`), **only include benchmark types that actually exercise framework features**. Framework benchmarks should measure framework overhead and benefits, not duplicate runtime capabilities.

## ‚úÖ INCLUDE for Framework Benchmarks

Create framework-specific implementations for these test types:

- **HTTP Servers** - Routing, middleware, request/response handling
- **Database ORMs** - If framework provides database abstractions
- **Template Rendering** - If framework provides templating engines
- **WebSocket Handling** - If framework provides WebSocket utilities
- **Authentication/Authorization** - Framework-specific auth middleware
- **Session Management** - Framework session handling
- **File Upload/Multipart** - Framework upload handling utilities

## ‚ùå EXCLUDE from Framework Benchmarks

Do NOT create framework-specific tests for these (use runtime tests instead):

- **File Read/Write Operations** - Use runtime APIs directly (`fs`, `Bun.file()`)
- **JSON Serialization** - Use language built-ins (`JSON.stringify()`)
- **Raw Concurrency Tests** - Test runtime concurrency, not framework
- **Basic I/O Operations** - Network requests, file system access
- **Crypto Operations** - Unless framework provides crypto utilities
- **String/Array Processing** - Use language primitives

## üéØ Validation Rule

**Before creating a framework benchmark, ask:**
> *"Does this test import and meaningfully use the framework?"*

If the answer is NO, use the runtime benchmark instead.

## Examples

### ‚úÖ Good Framework Test (Hono HTTP Server)
```typescript
import { Hono } from 'hono';  // ‚Üê Uses framework
const app = new Hono();      // ‚Üê Framework feature
app.get('/', (c) => c.json({...}));  // ‚Üê Framework routing
```

### ‚ùå Bad Framework Test (Hono File Read)
```typescript
// No framework imports or usage!
await Bun.file(filePath).text();  // ‚Üê Pure runtime API
```

## Technology Examples

### Hono Framework
- ‚úÖ Include: `http_server` (uses Hono routing/middleware)
- ‚ùå Exclude: `file_read`, `file_write`, `json_write`, `concurrency_test`

### Express Framework  
- ‚úÖ Include: `http_server`, `middleware_stack`, `template_render`
- ‚ùå Exclude: `file_operations`, `json_processing`, `crypto_ops`

## Configuration Reference

Framework technologies should only define benchmarks that exercise framework features in [config/technologies.yaml](mdc:config/technologies.yaml):

```yaml
hono-bun:
  name: "Hono (Bun Runtime)"
  benchmarks:
    http_server:  # ‚úÖ Uses Hono routing
      command: ["bun", "run", "benchmarks/hono-bun/http_server/index.ts"]
    # ‚ùå No file_read, json_write, etc. - use 'bun' technology instead
```

## Rationale

This approach:
- **Eliminates Duplication** - No duplicate tests that measure the same runtime capabilities
- **Meaningful Comparisons** - Framework vs framework overhead comparisons
- **Clear Separation** - Runtime performance vs framework performance
- **Maintenance** - Fewer redundant test implementations to maintain

**Remember**: If a test doesn't use the framework, it belongs in the runtime benchmark suite, not the framework suite.
